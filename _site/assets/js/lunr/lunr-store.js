var store = [{
        "title": "Go Redis连接池实现",
        "excerpt":"go-redis连接池实现 背景 因为inspector需要正式接入redis的秒级监控，在秒级监控场景下，如果redis driver的使用有任何不当，都有可能导致线上故障，所以特地了解了一下go-redis driver的具体实现：包括连接池实现方式，连接方式，失败重连机制，自动重连机制等。 主要struct结构     图1.1 go-redis主要struct结构在go-redis driver中主要有上面四个struct/interface，而返回给用户使用的就是Client struct了。Client有两个比较重要的成员，一个是baseClient，还有一个是cmdable，其中前者维护了一个连接池对象以及基础执行方法：process——执行单命令，processPipeline——批量执行命令，processTxPipeline——事务批量执行命令，而后者则是一个拥有redis基础命令function的struct。因为采集只会用到单命令模式，所以后面只会讲到这个命令。 主要方法 初始化 go-redis初始化时采用的lazy init的方式，对于当new一个client后，并不会直接创建连接，而只是初始化相关的option属性，并返回一个没有任何连接的client func NewClient(opt *Options) *Client {       opt.init()       c := Client{              baseClient: baseClient{                     opt:      opt,                     connPool: newConnPool(opt),              },       }       c.baseClient.init()       c.init()       return &amp;c}上面的newConnPool，c.baseClient.init和c.init方法都只是初始化需要的相关属性，不会有任何连接的建立。而newConnpool则是创建出对应的对象池队列： func NewConnPool(opt *Options) *ConnPool {       p := &amp;ConnPool{              opt: opt,              queue:     make(chan struct{}, opt.PoolSize),              conns:     make([]*Conn, 0, opt.PoolSize),              freeConns: make([]*Conn, 0, opt.PoolSize),       }       if opt.IdleTimeout &gt; 0 &amp;&amp; opt.IdleCheckFrequency &gt; 0 {              go p.reaper(opt.IdleCheckFrequency)       }       return p}我们可以看到，如果配置的idleTimeout或者idleCheckFrequncy参数，那么就会起一个协程，对空闲连接进行reap。在对于控制连接池大小上，这里使用了queue这个channel，这样就避免了对计数的原子比较和加减，也就避免了锁的使用。 执行操作 在执行操作的时候，Client会调用cmdable对象来执行对应的操作，而cmdable中的process对象则是来源于baseClient中的connpool func (c *cmdable) Ping() *StatusCmd {       cmd := NewStatusCmd(\"ping\")       c.process(cmd)       return cmd}通过这种方法，就将连接池和命令分离开来，这样也将常用的命令都封装在了一起。 如何获取链接 在每次真正执行操作之前，client都会调用connpool的Get方法，在这个Get方法中实现了链接的创建和获取。 select {\tcase p.queue &lt;- struct{}{}:\tdefault:\t\ttimer := timers.Get().(*time.Timer)\t\ttimer.Reset(p.opt.PoolTimeout)\t\tselect {\t\tcase p.queue &lt;- struct{}{}:\t\t\tif !timer.Stop() {\t\t\t\t&lt;-timer.C\t\t\t}\t\t\ttimers.Put(timer)\t\tcase &lt;-timer.C:\t\t\ttimers.Put(timer)\t\t\tatomic.AddUint32(&amp;p.stats.Timeouts, 1)\t\t\treturn nil, false, ErrPoolTimeout\t\t}\t}首先，这里会给connPool初始化时创建的channel发送一个信号，如果信号阻塞了，说明当前已经用满连接池的所有链接，那么此时会在timeout时间内，尝试继续发送信号，如果还是阻塞，则返回错误，否则即刻停止timer，进行后续操作。在这里有一个细节比较好，就是timer对象的对象池化，这样就不用频繁创建然后等gc去回收timer小对象了。不过这种优化必须在连接池被用满的情况下效果比较明显。还有强调一点的就是，这里并不获取任何连接，这里获取的是接下来获取真正连接的“资格”。当拿到获取链接的“资格”后，接下来便是去获取真正的链接 for {       p.freeConnsMu.Lock()       cn := p.popFree()       p.freeConnsMu.Unlock()       if cn == nil {              break       }       if cn.IsStale(p.opt.IdleTimeout) {              p.CloseConn(cn)              continue       }       atomic.AddUint32(&amp;p.stats.Hits, 1)       return cn, false, nil}这里先遍历Client中free conn数组，如果找到没有超过idleTimeout的链接，则返回，遍历期间，如果找到stale的conn，则会直接close掉。这里面其实有个可以优化的地方，因为如果free队列里面的所有conn都是stale的，那么后面会需要重新new，而这里完全可以留下一个当做本次使用（因为这个idleTimeout只是客户端的timeout），然后批量关闭stale的，因为close操作实现加了锁，这样锁使用量会少。 如何创建连接 opt.Dialer = func() (net.Conn, error) {       conn, err := net.DialTimeout(opt.Network, opt.Addr, opt.DialTimeout)       if opt.TLSConfig == nil || err != nil {              return conn, err       }       t := tls.Client(conn, opt.TLSConfig)       return t, t.Handshake()}创建连接，其实也就是创建了一个tcp连接 如何实现失败重连/自动重连 go-redis在每次执行命令失败以后，会判断当前失败类型，如果不是redis server的报错也不是设置网络timeout后的timeout报错，那么则会将该连接从连接池中remove掉，如果有设置重试次数，那么就会继续重试命令，又因为每次执行命令时会从连接池中获取链接，而没有又会新建，这样就变相实现了失败重连/自动重连机制。 if internal.IsBadConn(err, false) {       _ = c.connPool.Remove(cn)       return false}_ = c.connPool.Put(cn)return true通过这种方式，初始化好一个redis client之后，便不用再关注重连逻辑了。 ","categories": ["golang"],
        "tags": [],
        "url": "http://localhost:4000/golang/go-redis%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0/",
        "teaser":"http://localhost:4000/assets/pic/golang/go-redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"},{
        "title": "Golang map实现",
        "excerpt":"Golang map实现 前言 golang在自己的内置类型中实现了hashmap这种数据结构，而且这个hashmap的key支持任意能计算hash值的数据类型，可以说是十分方便了。因此我在各种项目中都大量使用了这种数据结构，但是越是这种通用型的数据结构，想要在某个特定的场景中用好，却不是一件那么简单的事情，所以为了不给项目埋坑，深入了解hashmap的实现就是一件十分有必要的事情了。 map基本原理 hashmap是一个十分常见也是十分经典的数据结构，而通常一个hashmap需要将key进行hash计算，然后映射到一个数组下标上，然后通过数组下标访问，达到O(1)时间复杂度快速访问，但是无论多美完美的hash算法，都会导致多个key的最后计算结果相同——即hash碰撞。而解决hash碰撞也有多种方法，比如退避法，拉链法等等。其中，拉链法是最为常见也是最为有效的方法，因此golang的hashmap也是采用的拉链法，但是golang在普通的拉链法上又做了许多性能上的优化。 golang hashmap基本概念原理 golang的hashmap是由一个个的桶(bucket)组成，每个桶额定可以放8个元素，通过hash算法定位桶的下标，然后在每个桶中再进行查找，如果某个hash值的元素个数超过8，那么则在桶后面拉链处一个新桶（overflow buckets），用来装新数据。然后除此外，这里还有一个loadFactor的概念，即桶平均的装载率。桶的装载率直接影响了overflow buckets的数目和内存使用率，通过作者测试，当loadFactor在6.5的时候能达到最好的平衡。  数据结构 在上述数据结构中，最为重要的就是bmap这个数据结构了，也就是上文介绍的一个bucket。bmap包含了两部分，第一个部分是tophash这样一个数据结构，这个主要作为在bucket中进行快速定位的一种“filter”，然后再后面就是8个key和8个value的数据空间，这部分数据的访问全部通过地址pointor+下标偏移来完成。然后最后一个就是一个pointor，用来指向overflow的bucket数据。 详细介绍 上面简单介绍了golang hashmap的基本原理，那么下面就通过增删改查操作来详细介绍一下它的一些实现细节，并通过这个来指导我们平时自己的使用 map初始化 map的初始化通过makemap方法实现，该方法会做一些合法性判断，然后如果传入了初始化大小，则会根据大小和loadFactor来创建对应数量的bucket func overLoadFactor(count int64, B uint8) bool {\t// TODO: rewrite to use integer math and comparison?\treturn count &gt;= bucketCnt &amp;&amp; float32(count) &gt;= loadFactor*float32((uintptr(1)&lt;&lt;B))}如果没有传大小，那么只会初始化map的数据结构，而不会创建任何的bucket——lazy init。 ","categories": ["golang"],
        "tags": [],
        "url": "http://localhost:4000/golang/golang-map%E5%AE%9E%E7%8E%B0/",
        "teaser":"http://localhost:4000/assets/pic/golang/go-hmap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"}]
